searchState.loadedDescShard("no_downtime_service", 0, "JWT Authentication Module\nCache implementation with stampede protection\nCircuit Breaker implementation for resilience patterns\nMetrics Collection Module\nOAuth2 Authentication Module\nRate limiter implementation for resilience patterns\nRetry mechanism implementation for resilience patterns\nDistributed Tracing Module\nJWT Authentication Error\nJWT Authentication State\nAuthenticated User Extractor\nJWT Claims structure\nToken expired\nInvalid authorization header format\nInvalid token\nMissing authorization header\nUser claims\nExpiration time\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate AuthState from RSA PEM strings\nGenerate a new JWT token for the given subject and roles\nIssued at time\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIssuer\nNot before time\nCreate a new AuthState with the provided keys\nRoles/permissions\nSubject (user identifier)\nValidate a JWT token and return the claims\nCache with stampede protection\nCache configuration\nCache statistics\nClean expired entries\nClear all entries from the cache\nCurrent number of entries\nDefault time-to-live for entries\nNumber of evictions\nProbability factor for early expiration (0.0 to 1.0)\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet a value from the cache\nGet a value from the cache or compute it if not present\nNumber of hits\nInsert a value into the cache\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMaximum number of entries\nNumber of misses\nCreate a new cache with default configuration\nWhether to use probabilistic early expiration\nRemove a value from the cache\nGet cache statistics\nCreate a new cache with custom configuration\nCircuit breaker implementation\nConfiguration for the circuit breaker\nCircuit breaker errors\nCircuit breaker states\nCircuit is closed and allowing requests\nCircuit is half-open, allowing limited requests to test …\nInner error from the wrapped function\nCircuit is open and rejecting requests\nCircuit is open and rejecting requests\nExecute a function with circuit breaker protection\nCheck if the circuit should attempt to close\nNumber of failures before opening the circuit\nForce the circuit to close\nForce the circuit to open\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new circuit breaker with default configuration\nGet the current state of the circuit breaker\nNumber of successful requests needed to close the circuit …\nTimeout before attempting to close the circuit again\nCreate a new circuit breaker with custom configuration\nPath to the TLS certificate file\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nPath to the TLS private key file\nTLS configuration (optional)\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSet the service as alive\nSet the service as not alive\nSet the service as not ready to accept traffic\nSet the service as ready to accept traffic\nMetrics collection struct\nGauge for active connections\nDecrement active connections\nCounter for errors\nReturns the argument unchanged.\nCounter for HTTP requests\nIncrement active connections\nIncrement errors counter\nIncrement HTTP requests counter\nCalls <code>U::from(self)</code>.\nCreate a new metrics instance\nRecord request duration\nGet the metrics registry\nHistogram for request duration\nSet active connections\nAccess token response\nOAuth2 Authorization Request Parameters\nAuthorization failed\nClaims structure\nMissing code parameter\nOAuth2 Configuration\nOAuth2 Error\nOAuth2 State\nOAuth2 User Extractor\nToken exchange failed\nToken validation failed\nAccess token\nAuthorization server URL\nGenerate authorization URL\nUser claims\nClient ID\nClient secret\nAuthorization code\nConfiguration\nError (if any)\nExchange authorization code for access token\nExpiration time\nExpires in (seconds)\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nIssued at time\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIssuer\nNot before time\nCreate a new OAuth2State\nHandler for OAuth2 callback\nHandler for initiating OAuth2 flow\nRedirect URL\nRefresh token (optional)\nRoles/permissions\nScope\nScopes\nState parameter\nSubject (user identifier)\nToken type\nToken exchange URL\nValidate access token\nLeaky bucket algorithm\nRate limiter implementation\nConfiguration for the rate limiter\nRate limiting algorithm\nToken bucket algorithm\nAlgorithm to use for rate limiting\nCheck if a request is allowed\nGet the current configuration\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new rate limiter with default configuration\nWhether to limit globally or per client\nCreate a new rate limiter with custom configuration\nMaximum capacity of the bucket\nLeak rate (requests per second)\nMaximum number of tokens in the bucket\nTokens added per second\nAll retry attempts failed\nOperation was cancelled\nRetry configuration\nError type for retry operations\nRetry mechanism implementation\nWhether to use exponential backoff\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nInitial delay between retries\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nJitter factor (0.0 to 1.0)\nMaximum number of retry attempts\nMaximum delay between retries\nMultiplier for exponential backoff\nCreate a new retry mechanism with default configuration\nExecute a function with retry logic\nExecute a function with retry logic and a cancellation …\nCreate a new retry mechanism with custom configuration\nInitialize basic tracing\nShutdown tracing gracefully")